import numpy as np
from scipy import stats
from scipy.stats import norm
from scipy.stats import uniform

import matplotlib.pylab as plt
print norm.__doc__

# Programming an Hybrid Markov Chain Montecarlo



class MCMC(object):
    """
        Generates a sample from a given (continuous) pdf using a MCMC algorithm 
        based on RW and Metropolis/Hastings acceptance rule
        
        (TODO): I think it was faster to sample a vectorized unif (or normal)
        than sampling after each step
    
    """    
    
    def __init__ (self, pdf = None, debug = False, niter = 10):
        """
        params::
            pdf:      Probability density function of the target
            chain:    The Markov Chain generated by the algorithm
            niter:    The number of iterations 
            debug:    A debugging flag
            
            (TODO): Allow to have as argument an unormalized mass density 
            function or a potential for HMC
            
        """
        
        self.pdf = pdf
        self.chain = np.zeros(niter)
        self.debug = debug
        self.niter = niter
        
    def make_proposal(self, previous):
        """
            Simple proposal mechanism via gaussian RW
        """
        proposal = previous + norm().rvs()
        return proposal
        
        
        
    def acceptance_rule(self, proposal, previous):
        u =  uniform.rvs()
        if self.debug:
            print u
            print (self.pdf(proposal)/self.pdf(previous) > u)
        
        
        if (self.pdf(proposal)/self.pdf(previous) > u):
            return proposal
        else:
            return previous
            
        
    def generate_sample(self):
        for k in xrange(self.niter - 1):            
            
            proposal = self.make_proposal(self.chain[k])
            
            if self.debug:
                print "Proposal %s: " % proposal

            self.chain[k + 1] = self.acceptance_rule(proposal, self.chain[k])
            
"""            
markov = MCMC(pdf = norm().pdf, niter = 1000)    
markov.generate_sample()
plt.hist(markov.chain)
plt.show()
"""

def test_MCMC( mode = "norm", niter = 1000):

    """
        Test function to check MCMC is working correctly.
        
        We sample from normal and uniform distrbution, plot 
        histograms of the chain and perform checks as:
            
            Normal: 
                JarqueBeraTests
                Compute Mean
                Compute Variance
                
            Uniform:
                Max and min
                
      TODO: ( Autocorrelation function)
    """
    
    if mode == "unif":
        
        MCMC_unif = MCMC(pdf = uniform( loc = -.5, scale = 1).pdf, 
        niter = niter)
        MCMC_unif.generate_sample()
        
        plt.hist(MCMC_unif.chain, bins = 100)
        plt.show()
        #print MCMC_unif.chain
        
    elif mode == "norm":    

        MCMC_norm = MCMC(pdf = norm( loc = -.5, scale = 1).pdf,
        niter = niter)
        MCMC_norm.generate_sample()
        
        plt.hist(MCMC_norm.chain, bins = 100)
        plt.show()
   
   
test_MCMC("unif", niter = 100000)

# test_MCMC()
# print uniform.__doc__
# print markov.chain
# print np.array.__doc__
# print np.zeros.__doc__